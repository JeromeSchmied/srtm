// use byteorder::{BigEndian, ReadBytesExt};
// use osmpbfreader::{OsmObj, OsmPbfReader};
// use reqwest::Error;
// use std::fs::File;
// use std::io::{self, BufReader, Read, Seek};
// use std::path::Path;

// const SAMPLES: u32 = 3601;

// fn read_elevation(file_path: &Path, lat: f64, lon: f64) -> io::Result<i16> {
//     let file = File::open(file_path)?;
//     let mut reader = BufReader::new(file);

//     // Calculate the row and column in the HGT file for the given coordinates
//     let row = ((lat.fract() * (SAMPLES - 1) as f64).round()) as u32;
//     let col = ((lon.fract() * (SAMPLES - 1) as f64).round()) as u32;

//     // Calculate the byte offset
//     let offset = ((row * SAMPLES + col) * 2) as u64;
//     reader.seek(io::SeekFrom::Start(offset))?;

//     // Read the elevation value (2 bytes, big-endian)
//     let elevation = reader.read_i16::<BigEndian>()?;
//     Ok(elevation)
// }

fn to_idx(coord: f64) -> u32 {
    ((coord.fract() * (3601 - 1) as f64).round()) as u32
}

fn main() {
    let args = std::env::args().collect::<Vec<_>>();

    let f_in = &args[1];
    let srtm = srtm::Tile::from_file(f_in)
        .inspect_err(|e| eprintln!("error reading file: {e:#?}"))
        .unwrap();
    println!(
        "tile resolution: {:?}, extent: {:?}; lat: {}; lon: {}",
        srtm.resolution,
        srtm.extent(),
        srtm.latitude,
        srtm.longitude
    );
    // 47.0745464,12.6938825
    // let großglockner = (47, 12);
    let großglockner = (47.0745464, 12.6938825);
    println!("großglockner\n\tposition: {:?}", großglockner);

    let (lat, lon): (f64, f64) = großglockner;
    let row = to_idx(lat);
    let col = to_idx(lon);

    println!("\taltitude: {}", srtm.get(row, col));

    // let (mut x, mut y) = (0, 0);
    let max_height = srtm.max_height();
    // for (i, row) in srtm
    //     .data
    //     .chunks(srtm.extent().try_into().unwrap())
    //     .enumerate()
    // {
    //     for (j, item) in row.iter().enumerate() {
    //         if item == &max_height {
    //             (x, y) = (j, i);

    //             break;
    //         }
    //     }
    // }

    for x in 0..srtm.extent() {
        for y in 0..srtm.extent() {
            if x >= srtm.extent() || y >= srtm.extent() {
                println!("({x};{y})");
            }
            let h = srtm.get(x, y);
            if h == max_height {
                println!("({x};{y}): {h}m");
            }
        }
    }

    // println!("max: ({x};{y}): {}m", max_height);

    // for (i, row) in srtm
    //     .data
    //     .chunks(srtm.extent().try_into().unwrap())
    //     .enumerate()
    // {
    //     println!("{i}");
    //     for (j, item) in row.iter().enumerate() {
    //         print!("\t{j}: {item}");
    //     }
    //     println!();
    // }

    // println!(
    //     "all height: {:#?}",
    //     srtm.data.chunks(srtm.extent().try_into().unwrap())
    // );

    // println!(
    //     "\taltitude: {:?}",
    //     read_elevation(Path::new(f_in), großglockner.0, großglockner.1)
    // );
}
